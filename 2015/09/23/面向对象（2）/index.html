<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>面向对象（2） · 陆涛博客</title><meta name="description" content="一、复习

异常：程序运行的时候出现的错误，出现来了错误以后我们就要进行错误处理


try{
 }catch(e){
 }

2.原型：原型是一个对象     A.原型是构造函数的原型属性     B.原型是实例对象的原型对象
3.如何通过原型来添加成员?   A.通过动态特性为原型添加成员   "><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">陆涛博客</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/Ben_wenbin"><i class="fa fa-twitter"></i></a></li><li><a href="http://instagram.com/hwbinbenben"><i class="fa fa-instagram"></i></a></li><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://weibo.com/ben0036"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="https://secure.gravatar.com/avatar/e71df8021446fe9759a9928b1dd5c28d?s=180&amp;r=G&amp;d="></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>面向对象（2）</a></h3></div><div class="post-content"><h4 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h4><blockquote>
<ol>
<li>异常：程序运行的时候出现的错误，出现来了错误以后我们就要进行错误处理</li>
</ol>
</blockquote>
<pre><code>try{
 }catch(e){
 }
</code></pre><blockquote>
<p>2.原型：原型是一个对象<br>     A.原型是构造函数的原型属性<br>     B.原型是实例对象的原型对象</p>
<p>3.如何通过原型来添加成员?<br>   A.通过动态特性为原型添加成员<br>   B.替换原型</p>
<p>4.如何访问原型<br>  A.构造函数通过原型属性访问原型 构造函数.prototype<br>  B.实例对象通过<strong>proto</strong>访问原型 例：实例对象.<strong>proto</strong>  或者 实例对象.constructor.prototype</p>
</blockquote>
<h4 id="二、如果修改原型对象中的属性值"><a href="#二、如果修改原型对象中的属性值" class="headerlink" title="二、如果修改原型对象中的属性值"></a>二、如果修改原型对象中的属性值</h4><blockquote>
<p>给当前对象的原型提供的属性赋值，实际上是给当前对象添加了该属性的新成员，并不会修改原型对象中的成员</p>
</blockquote>
<h4 id="三、混入"><a href="#三、混入" class="headerlink" title="三、混入"></a>三、混入</h4><blockquote>
<p>利用这个简单的赋值，就可以将一个对象的成员加到另一个对象上</p>
</blockquote>
<pre><code>var o1={&apos;name&apos;:&apos;andy&apos;};
var o2={&apos;age&apos;:19};
o2.name=o1.name;
//混入使得o2具有了age和o1中的name，即将o1混入到o2中
//混入也是一种继承方式
</code></pre><h4 id="四、如何使用代码实现混入"><a href="#四、如何使用代码实现混入" class="headerlink" title="四、如何使用代码实现混入"></a>四、如何使用代码实现混入</h4><blockquote>
<p>考虑要执行，写函数即可<br>由于将一个对象混入到另一个对象，所以有两个参数</p>
</blockquote>
<pre><code>function _mix_(obj,obj1){
    for(var k in obj1){
        obj[k]=obj1[k];
    }
 }
</code></pre><blockquote>
<p>在函数中，有一个默认的对象存在，即arguments。它里面存储着所有的传入的参数，arguments是函数中的一个对象，它包含了所有的参数，length属性表示参数的个数</p>
</blockquote>
<h4 id="五、原型式继承"><a href="#五、原型式继承" class="headerlink" title="五、原型式继承"></a>五、原型式继承</h4><blockquote>
<p>写一个构造函数，如果需要将其继承自某个特定的对象o，那么只需要设置该构造函数的prototype属性为o即可</p>
</blockquote>
<h4 id="六、混合式继承"><a href="#六、混合式继承" class="headerlink" title="六、混合式继承"></a>六、混合式继承</h4><blockquote>
<p>混合就是将多个对象的各个功能混合在一起，加到构造函数的原型对象上，那么该构造函数创建的实例，就继承多个对象了</p>
<ul>
<li>给原型对象添加混入方法（extend方法）</li>
<li>通过原型对象的混入方法给原型对象添加成员</li>
<li>只要是通过构造函数创建的实例</li>
</ul>
</blockquote>
<h4 id="七、使用Object-create创建对象"><a href="#七、使用Object-create创建对象" class="headerlink" title="七、使用Object.create创建对象"></a>七、使用Object.create创建对象</h4><blockquote>
<p>ES5提供的方法<br>1.基本的语法</p>
<ul>
<li>Object.create(对象) 使用一个对象作为原型创建一个新的对象，并返回</li>
<li>返回的是对象 </li>
<li>返回的对象满足：原型对象 就是 参数中的对象</li>
<li>新对象继承自参数<br>实现继承的快速方法<br>使用情况——假设我们不知道构造函数在哪里是什么，就不能new了，那就通过实例对象来创建一个类似的对象，然后就可以使用它了</li>
</ul>
</blockquote>
<pre><code>Object.create=function(o){
  function f(){};
  F.prototype=o;
  return new F();
};
</code></pre><h4 id="八、实现Object-create兼容"><a href="#八、实现Object-create兼容" class="headerlink" title="八、实现Object.create兼容"></a>八、实现Object.create兼容</h4><blockquote>
<p>先判断有没有，如果没有再加上</p>
</blockquote>
<pre><code> if ( !Object.create ) {
        Object.create =function ( o ) {
        function F() {}
        F.prototype = o;
        return new F();
    };
}
</code></pre><blockquote>
<p>直接在内置对象上添加成员，优点：和原生对象无缝对接，哪些方法是原生，哪些是个人的无法分清</p>
</blockquote>
<pre><code>// 在书写兼容代码的时候. 一般是写一个通用的函数或方法. 在函数或方法判断
// 是否具有原生的方法, 如果有直接使用系统自带的. 如果没有, 我们再自己实现
function createWithObject ( obj ) {
    if ( Object.create ) {
        return Object.create( obj );
    } else {
        function F() {}
        F.prototype = obj;
        return new F();
    }
} 
</code></pre><h4 id="九、对象的原型链"><a href="#九、对象的原型链" class="headerlink" title="九、对象的原型链"></a>九、对象的原型链</h4><blockquote>
<ol>
<li>凡是对象都有原型<ul>
<li>构造函数Person创建的对象p有原型Person.prototype</li>
<li>Person.prototype是对象，它也是有原型的</li>
<li>Person.prototype.<strong>proto</strong>里的constructor是Object，所以Person.prototype.<strong>proto</strong>就是Object.prototype</li>
<li>Object.prototype.<strong>proto</strong>是null，因此表明Object.prototype是顶级</li>
</ul>
</li>
<li>系统内置的原型链<ul>
<li>[]–》Array.prototype–》Object.prototype–》null</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="十、动态函数——Function"><a href="#十、动态函数——Function" class="headerlink" title="十、动态函数——Function"></a>十、动态函数——Function</h4><blockquote>
<p>在程序运行的时候，将一段字符串当做代码来执行，由于字符串可以随意的拼接，因此得到动态的执行</p>
<ul>
<li>eval</li>
<li>Function</li>
<li>定义动态函数，并执行<ul>
<li>使用Function构造函数，创建函数 Function是一个构造函数，new Function得到一个函数</li>
<li>语法<br>new Function（arg0，arg1,……，argN,body）  Function 的所有的参数，除了最后一个以外，都是生成的函数的参数，最后一个参数是函数体</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="十一、arguments对象"><a href="#十一、arguments对象" class="headerlink" title="十一、arguments对象"></a>十一、arguments对象</h4><blockquote>
<ul>
<li>arguments 凡是函数调用，都会默认含有一个arguments对象，可以将其看做为数组，里面存储着调用时传入的所有参数，可以使用数组的索引访问这些参数</li>
<li>函数名.length即函数名length属性，得到的是函数定义的时候的形参的个数</li>
</ul>
</blockquote>
<h4 id="十二、callee与caller"><a href="#十二、callee与caller" class="headerlink" title="十二、callee与caller"></a>十二、callee与caller</h4><blockquote>
<ul>
<li>js中的函数也是一个对象<ul>
<li>callee在函数的内部，它表示 当前函数 的引用</li>
<li>一般在函数内部，实现函数递归的时候，我们一般使用callee表示函数的引用</li>
<li>caller表示调用函数<br>在函数f1中调用函数f2<br>f1就是成为调用者，调用的发起人<br>f2就是被调用者<br>caller就是在被调用函数中，获得调用函数的引用</li>
</ul>
</li>
</ul>
</blockquote>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-09-23</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,http://yoursite.com/2015/09/23/面向对象（2）/,陆涛博客,面向对象（2）,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2015/10/02/面向对象（3）/" title="面向对象（3）" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2015/06/15/面向对象（1）/" title="面向对象（1）" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>